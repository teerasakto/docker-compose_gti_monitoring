{"version":3,"sources":["../../src/datasource-zabbix/zabbixDBConnector.js"],"names":["ZabbixDBConnectorFactory","datasourceSrv","backendSrv","ZabbixDBConnector","sqlDataSourceId","options","limit","DEFAULT_QUERY_LIMIT","loadSQLDataSource","datasourceId","ds","_","find","getAll","loadDatasource","name","then","sqlDataSourceType","meta","id","Promise","reject","testQuery","TEST_MYSQL_QUERY","TEST_POSTGRES_QUERY","invokeSQLQuery","items","timeFrom","timeTill","intervalMs","consolidateBy","intervalSec","Math","ceil","aggFunction","consolidateByFunc","grouped_items","groupBy","promises","map","value_type","itemids","join","table","HISTORY_TO_TABLE_MAP","dialect","query","buildSQLHistoryQuery","compactSQLQuery","all","flatten","results","TREND_TO_TABLE_MAP","valueColumn","includes","consolidateByTrendColumns","buildSQLTrendsQuery","history","addHostName","convertGrafanaTSResponse","queryDef","refId","format","rawSql","maxDataPoints","datasourceRequest","url","method","data","queries","response","series","time_series","hosts","uniqBy","grafanaSeries","itemid","item","alias","keys","length","host","hostid","datapoints","cloneDeep","points","target","sortBy","replace","buildPostgresHistoryQuery","buildMysqlHistoryQuery","buildPostgresTrendsQuery","buildMysqlTrendsQuery","time_expression","itemid_format","angular","module","factory"],"mappings":"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","file":"zabbixDBConnector.js","sourcesContent":["import angular from 'angular';\nimport _ from 'lodash';\n\nconst DEFAULT_QUERY_LIMIT = 10000;\nconst HISTORY_TO_TABLE_MAP = {\n  '0': 'history',\n  '1': 'history_str',\n  '2': 'history_log',\n  '3': 'history_uint',\n  '4': 'history_text'\n};\n\nconst TREND_TO_TABLE_MAP = {\n  '0': 'trends',\n  '3': 'trends_uint'\n};\n\nconst consolidateByFunc = {\n  'avg': 'AVG',\n  'min': 'MIN',\n  'max': 'MAX',\n  'sum': 'SUM',\n  'count': 'COUNT'\n};\n\nconst consolidateByTrendColumns = {\n  'avg': 'value_avg',\n  'min': 'value_min',\n  'max': 'value_max'\n};\n\n/** @ngInject */\nfunction ZabbixDBConnectorFactory(datasourceSrv, backendSrv) {\n\n  class ZabbixDBConnector {\n\n    constructor(sqlDataSourceId, options = {}) {\n      let {limit} = options;\n\n      this.sqlDataSourceId = sqlDataSourceId;\n      this.limit = limit || DEFAULT_QUERY_LIMIT;\n\n      this.loadSQLDataSource(sqlDataSourceId);\n    }\n\n    /**\n     * Try to load DS with given id to check it's exist.\n     * @param {*} datasourceId ID of SQL data source\n     */\n    loadSQLDataSource(datasourceId) {\n      let ds = _.find(datasourceSrv.getAll(), {'id': datasourceId});\n      if (ds) {\n        return datasourceSrv.loadDatasource(ds.name)\n        .then(ds => {\n          this.sqlDataSourceType = ds.meta.id;\n          return ds;\n        });\n      } else {\n        return Promise.reject(`SQL Data Source with ID ${datasourceId} not found`);\n      }\n    }\n\n    /**\n     * Try to invoke test query for one of Zabbix database tables.\n     */\n    testSQLDataSource() {\n      let testQuery = TEST_MYSQL_QUERY;\n      if (this.sqlDataSourceType === 'postgres') {\n        testQuery = TEST_POSTGRES_QUERY;\n      }\n      return this.invokeSQLQuery(testQuery);\n    }\n\n    getHistory(items, timeFrom, timeTill, options) {\n      let {intervalMs, consolidateBy} = options;\n      let intervalSec = Math.ceil(intervalMs / 1000);\n\n      consolidateBy = consolidateBy || 'avg';\n      let aggFunction = consolidateByFunc[consolidateBy];\n\n      // Group items by value type and perform request for each value type\n      let grouped_items = _.groupBy(items, 'value_type');\n      let promises = _.map(grouped_items, (items, value_type) => {\n        let itemids = _.map(items, 'itemid').join(', ');\n        let table = HISTORY_TO_TABLE_MAP[value_type];\n\n        let dialect = this.sqlDataSourceType;\n        let query = buildSQLHistoryQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, dialect);\n\n        query = compactSQLQuery(query);\n        return this.invokeSQLQuery(query);\n      });\n\n      return Promise.all(promises).then(results => {\n        return _.flatten(results);\n      });\n    }\n\n    getTrends(items, timeFrom, timeTill, options) {\n      let {intervalMs, consolidateBy} = options;\n      let intervalSec = Math.ceil(intervalMs / 1000);\n\n      consolidateBy = consolidateBy || 'avg';\n      let aggFunction = consolidateByFunc[consolidateBy];\n\n      // Group items by value type and perform request for each value type\n      let grouped_items = _.groupBy(items, 'value_type');\n      let promises = _.map(grouped_items, (items, value_type) => {\n        let itemids = _.map(items, 'itemid').join(', ');\n        let table = TREND_TO_TABLE_MAP[value_type];\n        let valueColumn = _.includes(['avg', 'min', 'max'], consolidateBy) ? consolidateBy : 'avg';\n        valueColumn = consolidateByTrendColumns[valueColumn];\n\n        let dialect = this.sqlDataSourceType;\n        let query = buildSQLTrendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn, dialect);\n\n        query = compactSQLQuery(query);\n        return this.invokeSQLQuery(query);\n      });\n\n      return Promise.all(promises).then(results => {\n        return _.flatten(results);\n      });\n    }\n\n    handleGrafanaTSResponse(history, items, addHostName = true) {\n      return convertGrafanaTSResponse(history, items, addHostName);\n    }\n\n    invokeSQLQuery(query) {\n      let queryDef = {\n        refId: 'A',\n        format: 'time_series',\n        datasourceId: this.sqlDataSourceId,\n        rawSql: query,\n        maxDataPoints: this.limit\n      };\n\n      return backendSrv.datasourceRequest({\n        url: '/api/tsdb/query',\n        method: 'POST',\n        data: {\n          queries: [queryDef],\n        }\n      })\n      .then(response => {\n        let results = response.data.results;\n        if (results['A']) {\n          return results['A'].series;\n        } else {\n          return null;\n        }\n      });\n    }\n  }\n\n  return ZabbixDBConnector;\n}\n\nangular\n  .module('grafana.services')\n  .factory('ZabbixDBConnector', ZabbixDBConnectorFactory);\n\n///////////////////////////////////////////////////////////////////////////////\n\nfunction convertGrafanaTSResponse(time_series, items, addHostName) {\n  var hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid'); //uniqBy is needed to deduplicate\n  let grafanaSeries = _.map(time_series, series => {\n    let itemid = series.name;\n    var item = _.find(items, {'itemid': itemid});\n    var alias = item.name;\n    if (_.keys(hosts).length > 1 && addHostName) { //only when actual multi hosts selected\n      var host = _.find(hosts, {'hostid': item.hostid});\n      alias = host.name + \": \" + alias;\n    }\n    // zabbixCachingProxy deduplicates requests and returns one time series for equal queries.\n    // Clone is needed to prevent changing of series object shared between all targets.\n    let datapoints = _.cloneDeep(series.points);\n    return {\n      target: alias,\n      datapoints: datapoints\n    };\n  });\n\n  return _.sortBy(grafanaSeries, 'target');\n}\n\nfunction compactSQLQuery(query) {\n  return query.replace(/\\s+/g, ' ');\n}\n\nfunction buildSQLHistoryQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, dialect = 'mysql') {\n  if (dialect === 'postgres') {\n    return buildPostgresHistoryQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction);\n  } else {\n    return buildMysqlHistoryQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction);\n  }\n}\n\nfunction buildSQLTrendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn, dialect = 'mysql') {\n  if (dialect === 'postgres') {\n    return buildPostgresTrendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn);\n  } else {\n    return buildMysqlTrendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn);\n  }\n}\n\n///////////\n// MySQL //\n///////////\n\nfunction buildMysqlHistoryQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction) {\n  let time_expression = `clock DIV ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT CAST(itemid AS CHAR) AS metric, ${time_expression} AS time_sec, ${aggFunction}(value) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY ${time_expression}, metric\n    ORDER BY time_sec ASC\n  `;\n  return query;\n}\n\nfunction buildMysqlTrendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn) {\n  let time_expression = `clock DIV ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT CAST(itemid AS CHAR) AS metric, ${time_expression} AS time_sec, ${aggFunction}(${valueColumn}) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY ${time_expression}, metric\n    ORDER BY time_sec ASC\n  `;\n  return query;\n}\n\nconst TEST_MYSQL_QUERY = `SELECT CAST(itemid AS CHAR) AS metric, clock AS time_sec, value_avg AS value FROM trends_uint LIMIT 1`;\n\n////////////////\n// PostgreSQL //\n////////////////\n\nconst itemid_format = 'FM99999999999999999999';\n\nfunction buildPostgresHistoryQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction) {\n  let time_expression = `clock / ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT to_char(itemid, '${itemid_format}') AS metric, ${time_expression} AS time, ${aggFunction}(value) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY 1, 2\n    ORDER BY time ASC\n  `;\n  return query;\n}\n\nfunction buildPostgresTrendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn) {\n  let time_expression = `clock / ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT to_char(itemid, '${itemid_format}') AS metric, ${time_expression} AS time, ${aggFunction}(${valueColumn}) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY 1, 2\n    ORDER BY time ASC\n  `;\n  return query;\n}\n\nconst TEST_POSTGRES_QUERY = `\n  SELECT to_char(itemid, '${itemid_format}') AS metric, clock AS time, value_avg AS value\n  FROM trends_uint LIMIT 1\n`;\n"]}